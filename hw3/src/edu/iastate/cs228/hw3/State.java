package edu.iastate.cs228.hw3;

import java.io.FileNotFoundException;
import java.io.FileReader;
import java.util.HashSet;
import java.util.Scanner;

/**
 *  
 * @author Gavin Monroe
 *
 */


/**
 * This class represents a board configuration in the 8-puzzle.  Only the initial configuration is 
 * generated by a constructor, while intermediate configurations will be generated via calling
 * the method successorState().  State objects will form two circular doubly-linked lists OPEN and 
 * CLOSED, which will be used by the A* algorithm to search for a path from a given initial board
 * configuration to the final board configuration below: 
 * 
 *  1 2 3 
 *  8   4
 *  7 6 5
 *
 * The final configuration (i.e., the goal state) above is not explicitly represented as an object 
 * of the State class. 
 */

public class State implements Cloneable, Comparable<State>
{
	public int[][] board; 		// configuration of tiles 
	
	public State previous;    	// previous node on the OPEN/CLOSED list
	public State next; 			// next node on the OPEN/CLOSED list
	public State predecessor; 	// predecessor node on the path from the initial state 
	
	public Move move;           // the move that generated this state from its predecessor
	public int numMoves; 	    // number of moves from the initial state to this state

	public static Heuristic heu; // heuristic used. shared by all the states. 
	
	private int numMismatchedTiles = -1;  // number of mismatched tiles between this state 
	                                      // and the goal state; negative if not computed yet.
	private int ManhattanDistance = -1;   // Manhattan distance between this state and the 
	                                      // goal state; negative if not computed yet. 


	public static int[][] goalBoard = { {1,2,3},
										{8,0,4},
										{7,6,5}}; // goal state configuration

	/**
	 * Constructor (for the initial state).  
	 * 
	 * It takes a 2-dimensional array representing an initial board configuration. The empty 
	 * square is represented by the number 0.  
	 * 
	 *     a) Initialize all three links previous, next, and predecessor to null.  
	 *     b) Set move to null and numMoves to zero.
	 * 
	 * @param board
	 * @throws IllegalArgumentException		if board is not a 3X3 array or its nine entries are 
	 * 										not respectively the digits 0, 1, ..., 8. 
	 */
    public State(int[][] board) throws IllegalArgumentException 
    {
    	this.board = board;

    	if (!validBoard())
		{
			throw new IllegalArgumentException();
		}

		predecessor = null;
		previous = null;
		next = null;
		move = null;
		numMoves = 0;
	}
    
    
    /**
     * Constructor (for the initial state) 
     * 
     * It takes a state from an input file that has three rows, each containing three digits 
     * separated by exactly one blank.  Every row starts with a digit. The nine digits are 
     * from 0 to 8 with no duplicates.  
     * 
     * Do the same initializations as for the first constructor. 
     * 
     * @param inputFileName
     * @throws FileNotFoundException
     * @throws IllegalArgumentException  if the file content does not meet the above requirements. 
     */
    public State (String inputFileName) throws FileNotFoundException, IllegalArgumentException
    {
		this.board = new int[3][3];

		// Read the input file
		Scanner in = new Scanner(new FileReader(inputFileName));
		for (int r = 0; r < 3; r++)
		{
			for (int c = 0; c < 3; c++)
			{
				board[r][c] = in.nextInt();
			}
		}
		in.close();

		if (!validBoard())
		{
			throw new IllegalArgumentException();
		}

		predecessor = null;
		previous = null;
		next = null;
		move = null;
		numMoves = 0;
	}

	/**
	 * Helper method to check a board content.
	 *
	 * @throws IllegalArgumentException  if the board does not meet the digits requirements.
	 * */
	private boolean validBoard() {
		// Check the board has correct dimensions
		if (board.length != 3)
		{
			return false;
		}
		if (board[0].length != 3)
		{
			return false;
		}
		// Check the board contains the right digits, and only once
		HashSet<Integer> digits = new HashSet<>();
		for (int r = 0; r < 3; r++)
		{
			for (int c = 0; c < 3; c++)
			{
				int digit = board[r][c];
				if (digit < 0 || digit > 8 || digits.contains(digit))
				{
					return false;
				}
				digits.add(digit);
			}
		}
		return true;
	}
    
    
    /**
     * Generate the successor state resulting from a given move.  Throw an exception if the move 
     * cannot be executed.  Besides setting the array board[][] properly, you also need to do the 
     * following:
     * 
     *     a) set the predecessor of the successor state to this state;
     *     b) set the private instance variable move of the successor state to the parameter m; 
     *     c) Set the links next and previous to null;  
     *     d) Update numMoves. 
     * 
     * @param m  one of the moves LEFT, RIGHT, UP, and DOWN
     * @return
     * @throws IllegalArgumentException if RIGHT when the empty square is in the left column, or 
     *                                  if LEFT when the empty square is in the right column, or 
     *                                  if UP when the empty square is in the bottom row, or 
     *                                  if DOWN when the empty square is in the top row. 
     */                                  
    public State successorState(Move m) throws IllegalArgumentException 
    {
    	// Find position of the empty
		int empty_r = 0, empty_c = 0;
		for (int r = 0; r < 3; r++)
		{
			for (int c = 0; c < 3; c++)
			{
				if (board[r][c] == 0)
				{
					empty_r = r;
					empty_c = c;
					break;
				}
			}
		}

		// Verify move is valid and set r/c to swap with the empty tile
		int target_r = empty_r, target_c = empty_c;
		if (m == Move.RIGHT && empty_c != 0)
		{
			target_c--;
		}
		else if (m == Move.LEFT && empty_c != 2)
		{
			target_c++;
		}
		else if (m == Move.UP && empty_r != 2)
		{
			target_r++;
		}
		else if (m == Move.DOWN && empty_r != 0)
		{
			target_r--;
		}
		else
		{
			throw new IllegalArgumentException(); // error if none is valid
		}

    	// Set the successor object
		State successor = (State)clone();

		int tmp = successor.board[target_r][target_c];
		successor.board[target_r][target_c] = successor.board[empty_r][empty_c];
		successor.board[empty_r][empty_c] = tmp;

		successor.move = m;
		successor.numMoves = this.numMoves + 1;
		successor.predecessor = this;

		return successor;
    }
    
        
    /**
     * Determines if the board configuration in this state can be rearranged into the goal configuration. 
     * According to the appendix in the project description, we check if this state has an odd number of 
     * inversions. 
     */
    /**
     * 
     * @return true if the puzzle starting in this state can be rearranged into the goal state.
     */
    public boolean solvable()
    {
    	// Convert to sequence and count inversion (count bigger digits on the left of a smaller one)
		int[] sequence = sequential();
		int inversions = 0;
		for (int i = 1; i < 9; i++)
		{
			int digit = sequence[i];
			if (digit != 0)
			{
				for (int j = 0; j < i; j++)
				{
					if (digit < sequence[j])
					{
						inversions++;
					}
				}
			}
		}

    	return (inversions % 2 == 1);
    }

	/**
	 * Returns a sequence containing the board digits.
	 * @return the board as a sequential array.
	 */
	public int[] sequential()
	{
		int[] sequence = new int[9];
		for (int r = 0; r < 3; r++)
		{
			for (int c = 0; c < 3; c++)
			{
				sequence[r * 3 + c] = board[r][c];
			}
		}
		return sequence;
	}
    
    
    /**
     * Check if this state is the goal state, namely, if the array board[][] stores the following contents: 
     * 
     * 		1 2 3 
     * 		8 0 4 
     * 		7 6 5 
     * 
     * @return
     */
    public boolean isGoalState()
    {
		for (int r = 0; r < 3; r++)
		{
			for (int c = 0; c < 3; c++)
			{
				if (board[r][c] != goalBoard[r][c])
				{
					return false;
				}
			}
		}
		return true;
    }
    
    
    /**
     * Write the board configuration according to the following format:
     * 
     *     a) Output row by row in three lines with no indentations.  
     *     b) Two adjacent tiles in each row have exactly one blank in between. 
     *     c) The empty square is represented by a blank.  
     *     
     * For example, 
     * 
     * 2   3
     * 1 8 4
     * 7 6 5  
     * 
     */
    @Override 
    public String toString()
    {
		StringBuilder s = new StringBuilder();
		for (int r = 0; r < 3; r++)
		{
			for (int c = 0; c < 3; c++)
			{
				if (board[r][c] == 0){
					s.append(' ');
				}else{
					s.append(board[r][c]);
				}
				s.append(' ');
			}
			s.append('\n');
		}
		return s.toString();
    }
    
    
    /**
     * Create a clone of this State object by copying over the board[][]. Set the links previous,
     * next, and predecessor to null. 
     * 
     * The method is called by SuccessorState(); 
     */
    @Override
    public Object clone()
    {
		int[][] newBoard = new int[3][3];
		for (int r = 0; r < 3; r++)
		{
			newBoard[r] = new int[3];
			for (int c = 0; c < 3; c++)
			{
				newBoard[r][c] = board[r][c];
			}
		}
		return new State(newBoard);
    }
  

    /**
     * Compare this state with the argument state.  Two states are equal if their arrays board[][] 
     * have the same content.
     */
    @Override 
    public boolean equals(Object o)
    {
    	if (o == null || !(o instanceof State))
		{
			return false;
		}
		else
		{
			// Check they are have the same content
			State other = (State) o;
			for (int r = 0; r < 3; r++)
			{
				for (int c = 0; c < 3; c++)
				{
					if (board[r][c] != other.board[r][c])
					{
						return false;
					}
				}
			}
		}
    	return true;
    }
        
    
    /**
     * Evaluate the cost of this state as the sum of the number of moves from the initial state and 
     * the estimated number of moves to the goal state using the heuristic stored in the instance 
     * variable heu. 
     * 
     * If heu == TileMismatch, add up numMoves and the return values from computeNumMismatchedTiles().
     * If heu == MahattanDist, add up numMoves and the return values of computeMahattanDistance(). 
     * 
     * @param h
     * @return estimated number of moves from the initial state to the goal state via this state.
     * @throws IllegalArgumentException if heuristic is neither 0 nor 1. 
     */
    public int cost() throws IllegalArgumentException
    {
    	if (heu == Heuristic.TileMismatch)
		{
			return numMoves + computeNumMismatchedTiles();
		}
		else if (heu == Heuristic.ManhattanDist)
		{
			return numMoves + computeManhattanDistance();
		}
		else
		{
			throw new IllegalArgumentException();
		}
    }

    
    /**
     * Compare two states by the cost. Let c1 and c2 be the costs of this state and the argument state s.
     * 
     * @return -1 if c1 < c2 
     *          0 if c1 = c2 
     *          1 if c1 > c2 
     *          
     * Call the method cost(). This comparison will be used in maintaining the OPEN list by the A* algorithm.
     */
    @Override
    public int compareTo(State s)
    {
    	int c1 = cost(), c2 = s.cost();
    	if (c1 < c2)
    	{
    		return -1;
		}
		else if (c1 > c2)
		{
			return 1;
		}
		else
		{
			return 0;
		}
    }
    

    /**
     * Return the value of numMismatchedTiles if it is non-negative, and compute the value otherwise. 
     * 
     * @return number of mismatched tiles between this state and the goal state. 
     */
	private int computeNumMismatchedTiles()
	{
		if (numMismatchedTiles >= 0)
		{
			return numMismatchedTiles;
		}

		// Calculate the number of non-0 tiles not in goal configuration
		numMismatchedTiles = 0;
		for (int r = 0; r < 3; r++)
		{
			for (int c = 0; c < 3; c++)
			{
				if (board[r][c] != 0 && board[r][c] != goalBoard[r][c])
				{
					numMismatchedTiles++;
				}
			}
		}
		return numMismatchedTiles;
	}

	
	/**
	 * Return the value of ManhattanDistance if it is non-negative, and compute the value otherwise.
	 * @return Manhattan distance between this state and the goal state. 
	 */
	private int computeManhattanDistance()
	{
		if (ManhattanDistance >= 0)
		{
			return ManhattanDistance;
		}

		// Calculate the distances of the tiles from their goal configuration
		ManhattanDistance = 0;
		for (int r = 0; r < 3; r++)
		{
			for (int c = 0; c < 3; c++)
			{
				// Find the correct tile on the goal configuration
				int digit = board[r][c];
				if (digit != 0)
				{
					for (int goal_r = 0; goal_r < 3; goal_r++)
					{
						for (int goal_c = 0; goal_c < 3; goal_c++)
						{
							int goalDigit = goalBoard[goal_r][goal_c];
							if (digit == goalDigit)
							{
								int distanceRows = Math.abs(r - goal_r);
								int distanceCols = Math.abs(c - goal_c);
								ManhattanDistance += (distanceRows + distanceCols);
							}
						}
					}
				}
			}
		}
		return ManhattanDistance;
	}
}
